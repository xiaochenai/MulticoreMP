package PC;

import java.io.*;
//import java.security.NoSuchAlgorithmException;

import javax.crypto.*;
import javax.crypto.spec.*;


public class GCM_DECRYPT
{
	public long KeyunBinding = 0;
	//decrypts the file given by input using the key keyIn and the IV
	public boolean gcmDecrypt(String input, String keyIn, String IV)
	{
	    byte[] inputKey = null;
	    SecretKey key = null;
	    boolean decrypted = false;
	    try 
	    {
	    	//gets the byte array of the hex keyIn string
			inputKey = keyFromHex(keyIn);
		} catch (IOException e1) { e1.printStackTrace();
		}
	      
	    try
	    {
	    	//creates the key
	          key = new SecretKeySpec(inputKey, "AES");
	    }
	    catch(Exception e)
	    {
	          System.out.println("Error in creating key");
	    }
	      
	    //creates a Decrypter object with the generated key and given IV
	    Decrypter decrypter = new Decrypter(key, IV);
	    try 
	    {
	    	//decrypts file
			decrypter.decrypt(getBytesFromFile(new File(input.replace(".txt", ".encrypted"))), input);
		} 
	    catch (IOException e) 
	    {
			e.printStackTrace();
		}
	    if(new File(input).exists())
	    {
	    	//deletes the ciphertext
	    	deleteFile(input.replace(".txt", ".encrypted"));
	    	decrypted = true;
	    }
	    else
	    {
	    	decrypted = false;
	    }

	    return decrypted;
	}
	
	 public static String ToHEX(byte[] text) throws IOException{
			
	 	   String hexString = "";
	 		for(int i = 0; i < text.length; i++)
	 		{
	 			String hex = Integer.toHexString(text[i]&0xFF );
	 			if (hex.length() == 1) {
	 			    hex = "0" + hex;
	 			}
	 			hexString = hexString + hex;
	 		}   
	 		return hexString;
	    }

	//decrypts the index using the byte array from the Android
	public void indexDecrypt(byte[] keyin,String secret)
	{
		long start = 0;
		SecretKey key_1 = null;
		byte[] key1 = null;
		byte[] key2 = null;
		byte[] key = null;
		String IV1 = "";
		
		try 
	    {
			start = System.currentTimeMillis();
			if(new File("Key1.txt").exists())
			{
				//gets the encrypted key generated by the encryption process
				key1 = keyFromHex(readLine("Key1.txt"));
				//decrypts the first key for generating master key
				key1 = TPMDecData.decryptData(key1,secret);			
				
			}
			System.out.println("keyin"+new String(keyin));
			System.out.println("key1"+new String(key1));

			key2 = keyin;
			//makes sure both keys have a value
			if(key1 != null && key2 != null)
			{
				//XORs the two keys to create the master key
				key = new byte[key1.length];
				for(int i = 0; i < key1.length; i++)
				{
					key[i] = (byte) (key1[i]^key2[i]);
				}
			}
			
			//reads the IV from the save file
			if(new File("IV1.txt").exists())
			{
				IV1= readLine("IV1.txt");
			}
		} catch (IOException e1) { e1.printStackTrace();
		}
	      
	    try
	    {
	    	//creates the key using the master key
	          key_1 = new SecretKeySpec(key1, "AES");
	    }
	    catch(Exception e)
	    {
	          System.out.println("Error in creating key");
	    }	
	    
	    KeyunBinding = System.currentTimeMillis() - start;
	    Decrypter decrypter = new Decrypter(key_1, IV1);
	    
	    try 
	    {
	    	if(new File("Index.encrypted").exists())
	    	{
	    		//decrypts the index
	    		decrypter.decrypt(getBytesFromFile(new File("Index.encrypted")), "Index.index");
	    	}
	    } 
	    catch (IOException e) 
	    {
			e.printStackTrace();
		}
	    if(new File("Index.index").exists())
	    {
	    	//deletes the ciphertext index file
	    	deleteFile("Index.encrypted");
	    }
	}
	
	//reads a line from the input file
	private static String readLine(String fileName) throws IOException 
    {
		String strLine = "";
    	try{
    		//reads the line from the file
    		  FileInputStream fstream = new FileInputStream(fileName);
    		  // Get the object of DataInputStream
    		  DataInputStream in = new DataInputStream(fstream);
    		  BufferedReader br = new BufferedReader(new InputStreamReader(in));
    		  strLine = br.readLine();
    		  
    		  //Close the input stream
    		  in.close();
    	}
    	//Catch exception if any
    	catch (Exception e)
    	{
    		  System.err.println("Error: " + e.getMessage());
    	}
    	
    	return strLine;
    }
	
	//converts the input hex string into a byte array
	private static byte[] keyFromHex(String input) throws IOException {
	    int len = input.length();
	    byte[] bKey = new byte[len / 2];
	    for (int i = 0; i < len; i += 2) {
	        bKey[i / 2] = (byte) ((Character.digit(input.charAt(i), 16) << 4)
	                             + Character.digit(input.charAt(i+1), 16));
	    }
	    return bKey;
	}
	
	//deletes a file
	 private static void deleteFile(String file)
	 {
		  File f1 = new File(file);
		  f1.delete();
	 }

	 //gets the contents from the input file
	 public static byte[] getBytesFromFile(File fileIn) throws IOException 
	 {
        InputStream is = new FileInputStream(fileIn);
        // Get the size of the file
        long length = fileIn.length();
    
        // Create the byte array to hold the data
        byte[] bytes = new byte[(int)length];
    
        // Read in the bytes
        int offset = 0;
        int numRead = 0;
        while (offset < bytes.length
               && (numRead=is.read(bytes, offset, bytes.length-offset)) >= 0) {
            offset += numRead;
        }
    
        // Ensure all the bytes have been read in
        if (offset < bytes.length) {
            extracted(fileIn);
        }
    
        // Close the input stream and return bytes
        is.close();
        return bytes;
    }

	 
	 //makes sure the file is completely read
	private static void extracted(File file) throws IOException {
		throw new IOException("Could not completely read file "+file.getName());
	}
	    
}
    
class Decrypter {
    Cipher dcipher;

    Decrypter(SecretKey key, String IVin) {
       
      try 
      {
    	  //gets the IV from the hex string
    	byte[] iv = IVFromHex(IVin);
        dcipher = Cipher.getInstance("AES/GCM/NoPadding","JsafeJCE");
        IvParameterSpec params = new IvParameterSpec(iv);
        
        //initializes the decryption cipher
        dcipher.init(Cipher.DECRYPT_MODE, key, params);
        } catch (javax.crypto.NoSuchPaddingException e) { System.out.println(e.getMessage());
        } catch (java.security.NoSuchAlgorithmException e) { System.out.println(e.getMessage());
        } catch (java.security.InvalidKeyException e) { System.out.println(e.getMessage());
        } catch (IllegalArgumentException e) { System.out.println(e.getMessage());
        } catch (Exception e){
            System.out.println(e.getMessage());
        }
    }

    //converts the hex string input to a byte array
	private static byte[] IVFromHex(String input) throws IOException 
	{
	    int len = input.length();
	    byte[] bIV = new byte[len / 2];
	    for (int i = 0; i < len; i += 2) {
	        bIV[i / 2] = (byte) ((Character.digit(input.charAt(i), 16) << 4)
	                             + Character.digit(input.charAt(i+1), 16));
	    }
	    return bIV;
	}
	
	//decrypts the input byte array an saves it in a file
    public void decrypt(byte[] in, String out) 
    {
            byte[] plainMessage = new byte[dcipher.getOutputSize(in.length)];
            byte[] authenticatedData = new byte[10];
            int outputLenUpdate = 0;
			try {
				outputLenUpdate = dcipher.update(authenticatedData,0, authenticatedData.length, plainMessage, 0);
			} catch (ShortBufferException e) {
				e.printStackTrace();
			}
                        
            try {
				outputLenUpdate += dcipher.update(in, 0, in.length, plainMessage, outputLenUpdate);
			} catch (ShortBufferException e) {
				e.printStackTrace();
			}
            try {
				dcipher.doFinal(plainMessage,outputLenUpdate);
			} catch (IllegalBlockSizeException e) {
				e.printStackTrace();
			} catch (ShortBufferException e) {
				e.printStackTrace();
			} catch (BadPaddingException e) {
				e.printStackTrace();
			}
            System.out.println("Decryption Successful. Data Written to: " + out);
            
            //saves the plaintext to the original file
            FileOutputStream output = null;
			try {
				output = new FileOutputStream(out);
				output.write(plainMessage);
	            output.close();
			} catch (FileNotFoundException e) {
				e.printStackTrace();
			}catch (IOException e) {
				e.printStackTrace();
			}

    }
   
}
